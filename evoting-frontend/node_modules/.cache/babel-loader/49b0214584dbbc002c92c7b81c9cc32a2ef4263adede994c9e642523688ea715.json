{"ast":null,"code":"import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyRegistrationError } from '../helpers/identifyRegistrationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"registration\" via WebAuthn attestation\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateRegistrationOptions()`\n * @param useAutoRegister (Optional) Try to silently create a passkey with the password manager that the user just signed in with. Defaults to `false`.\n */\nexport async function startRegistration(options) {\n  // @ts-ignore: Intentionally check for old call structure to warn about improper API call\n  if (!options.optionsJSON && options.challenge) {\n    console.warn('startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');\n    // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable\n    options = {\n      optionsJSON: options\n    };\n  }\n  const {\n    optionsJSON,\n    useAutoRegister = false\n  } = options;\n  if (!browserSupportsWebAuthn()) {\n    throw new Error('WebAuthn is not supported in this browser');\n  }\n  // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n  const publicKey = {\n    ...optionsJSON,\n    challenge: base64URLStringToBuffer(optionsJSON.challenge),\n    user: {\n      ...optionsJSON.user,\n      id: base64URLStringToBuffer(optionsJSON.user.id)\n    },\n    excludeCredentials: optionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor)\n  };\n  // Prepare options for `.create()`\n  const createOptions = {};\n  /**\n   * Try to use conditional create to register a passkey for the user with the password manager\n   * the user just used to authenticate with. The user won't be shown any prominent UI by the\n   * browser.\n   */\n  if (useAutoRegister) {\n    // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n    createOptions.mediation = 'conditional';\n  }\n  // Finalize options\n  createOptions.publicKey = publicKey;\n  // Set up the ability to cancel this request if the user attempts another\n  createOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n  // Wait for the user to complete attestation\n  let credential;\n  try {\n    credential = await navigator.credentials.create(createOptions);\n  } catch (err) {\n    throw identifyRegistrationError({\n      error: err,\n      options: createOptions\n    });\n  }\n  if (!credential) {\n    throw new Error('Registration was not completed');\n  }\n  const {\n    id,\n    rawId,\n    response,\n    type\n  } = credential;\n  // Continue to play it safe with `getTransports()` for now, even when L3 types say it's required\n  let transports = undefined;\n  if (typeof response.getTransports === 'function') {\n    transports = response.getTransports();\n  }\n  // L3 says this is required, but browser and webview support are still not guaranteed.\n  let responsePublicKeyAlgorithm = undefined;\n  if (typeof response.getPublicKeyAlgorithm === 'function') {\n    try {\n      responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n    } catch (error) {\n      warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n    }\n  }\n  let responsePublicKey = undefined;\n  if (typeof response.getPublicKey === 'function') {\n    try {\n      const _publicKey = response.getPublicKey();\n      if (_publicKey !== null) {\n        responsePublicKey = bufferToBase64URLString(_publicKey);\n      }\n    } catch (error) {\n      warnOnBrokenImplementation('getPublicKey()', error);\n    }\n  }\n  // L3 says this is required, but browser and webview support are still not guaranteed.\n  let responseAuthenticatorData;\n  if (typeof response.getAuthenticatorData === 'function') {\n    try {\n      responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n    } catch (error) {\n      warnOnBrokenImplementation('getAuthenticatorData()', error);\n    }\n  }\n  return {\n    id,\n    rawId: bufferToBase64URLString(rawId),\n    response: {\n      attestationObject: bufferToBase64URLString(response.attestationObject),\n      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n      transports,\n      publicKeyAlgorithm: responsePublicKeyAlgorithm,\n      publicKey: responsePublicKey,\n      authenticatorData: responseAuthenticatorData\n    },\n    type,\n    clientExtensionResults: credential.getClientExtensionResults(),\n    authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)\n  };\n}\n/**\n * Visibly warn when we detect an issue related to a passkey provider intercepting WebAuthn API\n * calls\n */\nfunction warnOnBrokenImplementation(methodName, cause) {\n  console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}","map":{"version":3,"names":["bufferToBase64URLString","base64URLStringToBuffer","browserSupportsWebAuthn","toPublicKeyCredentialDescriptor","identifyRegistrationError","WebAuthnAbortService","toAuthenticatorAttachment","startRegistration","options","optionsJSON","challenge","console","warn","useAutoRegister","Error","publicKey","user","id","excludeCredentials","map","createOptions","mediation","signal","createNewAbortSignal","credential","navigator","credentials","create","err","error","rawId","response","type","transports","undefined","getTransports","responsePublicKeyAlgorithm","getPublicKeyAlgorithm","warnOnBrokenImplementation","responsePublicKey","getPublicKey","_publicKey","responseAuthenticatorData","getAuthenticatorData","attestationObject","clientDataJSON","publicKeyAlgorithm","authenticatorData","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","methodName","cause"],"sources":["C:/Users/Ajaykumar Kavassery/contracts/evoting-project/evoting-frontend/node_modules/@simplewebauthn/browser/esm/methods/startRegistration.js"],"sourcesContent":["import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyRegistrationError } from '../helpers/identifyRegistrationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"registration\" via WebAuthn attestation\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateRegistrationOptions()`\n * @param useAutoRegister (Optional) Try to silently create a passkey with the password manager that the user just signed in with. Defaults to `false`.\n */\nexport async function startRegistration(options) {\n    // @ts-ignore: Intentionally check for old call structure to warn about improper API call\n    if (!options.optionsJSON && options.challenge) {\n        console.warn('startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');\n        // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable\n        options = { optionsJSON: options };\n    }\n    const { optionsJSON, useAutoRegister = false } = options;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        user: {\n            ...optionsJSON.user,\n            id: base64URLStringToBuffer(optionsJSON.user.id),\n        },\n        excludeCredentials: optionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    // Prepare options for `.create()`\n    const createOptions = {};\n    /**\n     * Try to use conditional create to register a passkey for the user with the password manager\n     * the user just used to authenticate with. The user won't be shown any prominent UI by the\n     * browser.\n     */\n    if (useAutoRegister) {\n        // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        createOptions.mediation = 'conditional';\n    }\n    // Finalize options\n    createOptions.publicKey = publicKey;\n    // Set up the ability to cancel this request if the user attempts another\n    createOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n    // Wait for the user to complete attestation\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(createOptions));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options: createOptions });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    // Continue to play it safe with `getTransports()` for now, even when L3 types say it's required\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    // L3 says this is required, but browser and webview support are still not guaranteed.\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    // L3 says this is required, but browser and webview support are still not guaranteed.\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n/**\n * Visibly warn when we detect an issue related to a passkey provider intercepting WebAuthn API\n * calls\n */\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}